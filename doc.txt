1) Ambiente virtuale (Windows)

python -m venv venv
    # crea un ambiente virtuale nella cartella venv\

.\venv\Scripts\Activate
    # attiva il venv (PowerShell)
    #  • modifica PATH → usa python/pip del venv
    #  • imposta VIRTUAL_ENV
    #  • aggiunge (venv) al prompt

python --version      # Python 3.13
pip --version         # pip 25.2
pip install --upgrade pip

2) Installazione dipendenze

pip install "fastapi[standard]"
    # FastAPI + uvicorn (con extras: uvloop, httptools, watchfiles, multipart, jinja2, pyyaml, itsdangerous)

pip install sqlalchemy[asyncio]
    # SQLAlchemy 2.x con AsyncSession / create_async_engine

pip install asyncpg
    # driver asincrono PostgreSQL

pip install pydantic-settings
    # settings da env/.env (Pydantic v2)

pip install python-dotenv
    # carica variabili da .env (sviluppo)

pip install alembic
    # migrazioni database

pip install redis
    # client Redis (caching, rate limiting, code)

---
pip list # ritorna la lista di tutte le dipendenze installate 
pip freeze > requirements.txt   # blocca le versioni attuali
# Per ricreare l’ambiente: pip install -r requirements.txt

3) Bootstrap struttura progetto

mkdir app, app\api, app\api\v1, app\domain, app\domain\models, app\domain\repositories, app\infrastructure, app\infrastructure\repositories, app\schemas, app\services
    # crea le cartelle principali

New-Item app\main.py -ItemType File
    # entrypoint dell'app (inserirai il codice già preparato)

Copy-Item .env.example .env
    # copia un .env.example in .env
    # poi modifica .env (DATABASE_URL, pool, ecc.)

4) Migrazioni con Alembic

alembic init alembic
    # crea cartella alembic\ e file alembic.ini
    # In alembic.ini: imposta sqlalchemy.url oppure usa DATABASE_URL da env.
    # In alembic\env.py: importa la tua Base e imposta target_metadata = Base.metadata.

alembic revision -m "init" --autogenerate   # genera la prima revisione
alembic upgrade head                        # applica le migrazioni

5) Avvio locale (sviluppo)

uvicorn app.main:app --reload
    # http://127.0.0.1:8000/
    # /docs → Swagger, /redoc → ReDoc

6) Docker Compose (Windows)

docker compose up -d --build
    # avvia: app, db (Postgres), redis, (eventuale) pgadmin

docker compose logs -f app     # segue i log dell'app
docker compose ps              # stato container
docker compose exec app alembic upgrade head  # migrazioni dentro il container

curl http://127.0.0.1:8000/
# {"status":"ok"}

docker compose down     # ferma e rimuove i container (mantiene volumi)
docker compose down -v  # rimuove anche i volumi (ATTENZIONE: cancella i dati DB)

7) Note operative (Windows/Prod)

Workers & pool DB: dimensiona pool_size/max_overflow in funzione dei workers.

In produzione: usa gunicorn con workers Uvicorn (in container Linux).

Esempio (in Docker Linux):
gunicorn -k uvicorn.workers.UvicornWorker -w 4 -b 0.0.0.0:8000 app.main:app

Produzione: niente --reload né volume bind del codice; builda un’immagine “chiusa”.
Caching: Redis per liste/lookup frequenti; invalidazione su write.
Osservabilità: log strutturati, metriche (Prometheus), tracing (OpenTelemetry).
Sicurezza: CORS, limiti payload, validazione Pydantic, upload sicuri.
Task lenti: Celery/RQ + Redis (non bloccare le request HTTP).